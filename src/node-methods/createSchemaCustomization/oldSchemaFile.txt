const createSchemasForType = (object, typeSlug) => {
  const fields = {};
  let subTypes = [];

  //**
  object.forEach((field) => {
    const { key, type } = field;

    switch (type) {
      case 'text':
      case 'textarea':
      case 'html-textarea':
      case 'markdown':
      case 'select-dropdown':
      case 'radio-buttons':
        fields[key] = 'String';
        break;
      // letting numbers be auto detected for now
      case 'date':
        fields[key] = 'Date';
        break;
      case 'check-boxes':
        fields[key] = '[String]';
        break;
      case 'switch':
        fields[key] = 'Boolean';
        break;
      case 'file':
        // Note may need to do add a setting to allow remote vs local files here
        // Looks like I can put a resolver here https://www.gatsbyjs.com/docs/reference/graphql-data-layer/schema-customization/#gatsby-type-builders
        fields[key] = 'File';
        break;
      case 'number':
        fields[key] = {
          type: 'Float',
          resolve: (source) => {
            if (typeof source[key] !== 'number') return null;
            return source[key];
          },
        };
        break;
      case 'json':
        fields[key] = {
          type: 'String',
          resolve: (source) => {
            if (typeof source[key] !== 'object') return null;
            return JSON.stringify(source[key]);
          },
        };
        break;
      case 'parent':
        fields[key] = `${typeSlug}${capitalizeFirstLetter(key)}`;
        subTypes = subTypes.concat(createSchemasForType(field.children, `${typeSlug}${capitalizeFirstLetter(key)}`));
        break;
      case 'repeater':
        break;
      // Note this also may be the place to do object relationships?
      default:
        break;
    }
  });

  const finalSchema = {
    name: typeSlug,
    fields,
    interfaces: [],
    extensions: {
      infer: false,
    },
  };

  return [finalSchema].concat(subTypes);
};